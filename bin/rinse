#!/usr/bin/perl -w

=head1 NAME

rinse - RPM Installation Entity.

=head1 SYNOPSIS

  rinse [options]

  Help Options:
   --help     Show help information.
   --manual   Read the manual for this script.
   --version  Show the version information and exit.

  Mandatory Options:
   --directory    The directory to install the distribution within.
   --distribution The distribution to install.

  Misc Options:
   --arch                Specify the architecture to install.
   --cache               Should we use a local cache?  (Default is 1)
   --cache-dir           Specify the directory we should use for the cache.
   --clean-cache         Clean our cache of .rpm files.
   --list-distributions  Show installable distributions.
   --print-uris          Only show the RPMs which should be downloaded.

=cut


=head1 OPTIONS

=over 8

=item B<--arch>
Specify the architecture to install.  Valid choices are 'amd64' and 'i386' only.

=item B<--cache>
Specify whether to cache packages (1) or not (0).

=item B<--cache-dir>
Specify the directory we should use for the cache.

=item B<--clean-cache>
Remove all cached .rpm files.

=item B<--directory>
Specify the directory into which the distribution should be installed.

=item B<--distribution>
Specify the distribution to be installed.

=item B<--help>
Show help information.

=item B<--list-distributions>
Show the distributions which are installable.

=item B<--manual>
Read the manual for this script.

=item B<--print-uris>
Only show the files we would download, don't actually do so.

=item B<--version>
Show the version number and exit.

=back

=cut


=head1 DESCRIPTION

  rinse is a simple script which is designed to be able to install
 a minimal working installation of an RPM-based distribution into
 a directory.

  The tool is analagous to the standard Debian GNU/Linux debootstrap
 utility.

=cut


=head1 TODO

  Short of supporting more distributions or architectures there aren't
 really any outstanding issues.

=cut


=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

 $Id: rinse,v 1.18 2007-07-21 21:59:54 steve Exp $

=cut


=head1 LICENSE

Copyright (c) 2007 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut



#
#  Good practise
#
use strict;
use warnings;

#
#  Standard Perl modules we require
#
use English;
use File::Copy;
use File::Path;
use File::Find;
use Getopt::Long;
use Pod::Usage;
use LWP::UserAgent;




#
# Release number.
#
my $RELEASE = '0.5';


#
#  Our confiuration options.
#
my %CONFIG;

#
#  Default options.
#
$CONFIG{'arch'}      = 'i386';
$CONFIG{'cache'}     = 1;
$CONFIG{'cache-dir'} = "/var/cache/rinse/";



#
#  Make sure the host is setup correctly, and that all required
# tools are available.
#
testSetup();


#
#  Parse our arguments
#
parseCommandLineArguments();


#
#  Handle special case first.
#
if ( $CONFIG{'list-distributions'} )
{
    listDistributions();
    exit;
}
if ( $CONFIG{'clean-cache'} )
{
    cleanCache();
    exit;
}


#
#  Sanity check our arguments
#
sanityCheckArguments();


#
#  Ensure we're started by root at this point.  This is required
# to make sure we mount /proc, etc.
#
testRootUser();


#
#  Make sure the directory we're installing into exists.
#
if ( ! -d $CONFIG{'directory'} )
{
    #
    # Make the directory, including all required parent(s) directories.
    #
    mkpath( $CONFIG{'directory'}, 0, 0755 );
}


#
#  Find the list of packages to download
#
my @packages = getDistributionPackageList( $CONFIG{'distribution'} );


#
#  Find the mirror, if not specified already.
#
if ( ! $CONFIG{'mirror'} )
{
  $CONFIG{'mirror'} = getDistributionMirror( $CONFIG{'distribution'} );
}


#
#
#  Download the packages into the specified directory
#
downloadPackagesToDirectory( $CONFIG{'directory'}, $CONFIG{'mirror'}, @packages );


#
#  If we're only printing then exit here.
#
exit if ( $CONFIG{'print-uris'} );


#
#  Unpack the packages
#
unpackPackages( $CONFIG{'directory'} );


#
#  Now run the post-installation customization.
#
postInstallationCustomization( $CONFIG{'distribution'}, $CONFIG{'directory'} );


#
#  All done
#
print "Installation complete.\n";
exit;







=begin doc

  This routine is designed to test that the host system we're running
 upon has all the required binaries present.

  If any are missing then we'll abort.

=end doc

=cut

sub testSetup
{

    my @required = qw/ alien rpm wget /;

    foreach my $file ( @required )
    {
        if ( ( ! -x "/bin/$file" ) &&
             ( ! -x "/usr/bin/$file" ) )
        {
            print "The following (required) binary appears to be missing:\n";
            print "\t" . $file . "\n";
            print "Aborting...\n";
            exit;
        }
    }
}



=begin doc

  Make sure this script is being run by a user with UID 0.

=end doc

=cut

sub testRootUser
{
    if ( $EFFECTIVE_USER_ID != 0 )
    {
        print<<E_O_ROOT;

  In order to use this script you must be running with root privileges.

  This is necessary to mount /proc inside the new install and run
  chroot, etc.

E_O_ROOT
        exit;
    }
}



=begin doc

  Parse our command line arguments.

=end doc

=cut

sub parseCommandLineArguments
{
    my $HELP    = 0;
    my $MANUAL  = 0;
    my $VERSION = 0;

    #
    #  Parse options.
    #
    GetOptions(
               # Main options
               "directory=s",        \$CONFIG{'directory'},
               "distribution=s",     \$CONFIG{'distribution'},

               # Misc options.
               "arch=s",             \$CONFIG{'arch'},
               "cache=s",            \$CONFIG{'cache'},
               "cache-dir=s",        \$CONFIG{'cache-dir'},
               "clean-cache",        \$CONFIG{'clean-cache'},
               "list-distributions", \$CONFIG{'list-distributions'},
               "print-uris",         \$CONFIG{'print-uris'},

               # Help options
               "help",         \$HELP,
               "manual",       \$MANUAL,
               "verbose",      \$CONFIG{'verbose'},
               "version",      \$VERSION

              );

    pod2usage(1) if $HELP;
    pod2usage(-verbose => 2 ) if $MANUAL;


    if ( $VERSION )
    {
        my $REVISION      = '$Revision: 1.18 $';
        if ( $REVISION =~ /1.([0-9.]+) / )
        {
            $REVISION = $1;
        }

        print( "rinse release $RELEASE - CVS: $REVISION\n" );
        exit;
    }
}



=begin doc

  Test that our arguments are sane and sensible.

  Mostly this just means ensuring that mandatory options are present.

=end doc

=cut

sub sanityCheckArguments
{
    #
    #  Distribution is mandatory
    #
    if ( ! $CONFIG{'distribution'} )
    {
        print <<EOF;

  The name of the distribution to install is mandatory.

  To see all supported distributions run:

$0 --list-distributions

EOF
        exit;
    }


    #
    #  Installation root is mandatory
    #
    if ( ! $CONFIG{'directory'} )
    {
        print <<EOF;

  The directory to install into is mandatory.  Please specify one with
 --directory

EOF
        exit;
    }

    if ( $CONFIG{'arch'} )
    {
        if ( ( $CONFIG{'arch'} ne "i386" ) &&
             ( $CONFIG{'arch'} ne "amd64" ) )
        {
            print <<EOARCH;

  Only two architectures are supported:

   i386
   amd64

EOARCH
            exit;
        }
    }
}



=begin doc

  Show the distributions we are capable of installing.

=end doc

=cut

sub listDistributions
{
    my @avail;

    #
    #  An installable distribution requires both:
    #
    #  1.  A package/configuration file.
    #
    #  2.  A scripts directory.  (Even if empty!)
    #
    foreach my $file ( glob( "/etc/rinse/*.packages" ) )
    {
        #
        #  Get the name - so that we can test for the directory.
        #
        if ( $file =~ /^(.*)\/(.*)\.packages$/ )
        {
            push @avail, $2 if ( -d "/usr/lib/rinse/" . $2 );
        }
    }

    if ( @avail )
    {
        print "The following distributions are available:\n";
        foreach my $a ( @avail )
        {
            print "\t$a\n";
        }
    }
}



=begin doc

  Clean our cache of .rpm files.

=end doc

=cut

sub cleanCache
{
    my $dir = $CONFIG{'cache-dir'};

    #
    #  Nested function to remove .rpm files.
    #
    sub removePackages
    {
        my $file = $File::Find::name;
        if ( $file =~ /\.rpm$/ )
        {
            $CONFIG{'verbose'} && print "Removing: $file\n";
            unlink( $file );
        }
    }

    #
    #  Call our function.
    #
    find( { wanted => \&removePackages, no_chdir => 1 }, $dir );

}



=begin doc

  Return the list of packagse which are required for a basic
 installation of the specified distribution.

  These packages are located in the configuration file in /etc/rinse.

=end doc

=cut

sub getDistributionPackageList
{
    my( $distribution ) = (@_);

    my $file = "/etc/rinse/$distribution.packages";

    if ( ! -e $file )
    {
        print <<EOF;

  The package list for the distribution $distribution was not found.

  We expected to find:

    $file

  Aborting.

EOF
        exit;
    }

    #
    #  Read the file, skipping blank lines and comments
    #
    my @packages;


    open( FILE, "<", $file ) or die "Failed to open $file - $!";
    foreach my $line ( <FILE> )
    {
        next if ( !$line );
        chomp( $line );
        next if ( $line =~ /^#/ );
        next if ( !length( $line ) );

        push( @packages, $line );
    }
    close( FILE );

    #
    #  Return the list in a sorted fashion.
    #
    return( sort {lc($a) cmp lc($b) } @packages );
}



=begin doc

  Find the mirror which should be used for the specified distribution.

=end doc

=cut

sub getDistributionMirror
{
    my( $distribution ) = (@_);

    my $file = "/etc/rinse/$distribution.conf";

    if ( ! -e $file )
    {
        print <<EOF;

  The configuration file for the distribution $distribution was not found.

  We expected to find:

    $file

  Aborting.

EOF
        exit;
    }

    #
    #  Read the file, skipping blank lines and comments
    #
    my %options;

    open( FILE, "<", $file ) or die "Failed to open $file - $!";
    foreach my $line ( <FILE> )
    {
        next if ( !$line );
        next if ( $line =~ /^#/ );

        chomp( $line );

        if ( $line =~ /([^=]+)=([^\n]+)/ )
        {
            my $key = $1;
            my $val = $2;

            # Strip leading and trailing whitespace.
            $key =~ s/^\s+//;
            $key =~ s/\s+$//;
            $val =~ s/^\s+//;
            $val =~ s/\s+$//;

            $options{$key} = $val;
        }
    }
    close( FILE );


    #
    #  Now look for a mirror which matches our arch
    #
    if ( $options{'mirror' . "." . $CONFIG{'arch'}} )
    {
        return( $options{'mirror' . "." . $CONFIG{'arch'}} );
    }
    else
    {
        return $options{'mirror'};
    }

    #
    #  Broken?
    #
    print <<EOF;

  Failed to find a mirror setting in $file.

EOF

    exit;
}



=begin doc

  Attempt to download each of the named packages from the specified
 mirror, and place them in the given directory.

  Use the cache unless we're not supposed to.

=end doc

=cut

sub downloadPackagesToDirectory
{
    my( $dir, $mirror, @packages ) = ( @_ );

    #
    #  Cache directory.
    #
    my $cache = "$CONFIG{'cache-dir'}/$CONFIG{'distribution'}.$CONFIG{'arch'}/";

    #
    #  Unless we've been told not to then copy packages from
    # the cache.
    #
    if( $CONFIG{'cache'} )
    {
        #
        #  Make sure we have a cache directory.
        #
        if ( -d $cache )
        {
            $CONFIG{'verbose'} && print "Copying files from cache directory: $cache\n";
            copyPackageFiles( $cache, $dir );
        }
    }

    #
    #  Find the links available for download on our mirror.
    #
    my %links = findMirrorContents( $mirror );


    #
    #  Count of links, and the currently active download.
    # Used purely for the status updates..
    #
    my $count = 0;
    my $total = $#packages;

    #
    #  Process each package we're supposed to fetch.
    #
    foreach my $package ( @packages )
    {
        my $found = 0;

        $CONFIG{'verbose'} && print "-Download $package\n";

        #
        # Find the candidate package to download from our list of links.
        #
        foreach my $key ( keys %links )
        {
            #
            #  If we have haven't found the package yet, and the name
            # of the link is *longer* than the name of the package we're
            # looking for.
            #
            #  (ie. to cope with -$ver.$arch.$rpm).
            #
            if ( ( ! $found ) &&
                 ( length( $key ) > length( $package ) ) )
            {
                # get the substring of the link we've got
                my $pre = substr( $key, 0, length( $package ) );
                my $post= substr( $key, length( $package ), 2 );

                if ( ( lc( $pre ) eq lc( $package ) ) &&
                     $post =~ /-[0-9]/ )
                {
                    $found += 1;

                    if ( $CONFIG{'print-uris'} )
                    {
                        print $mirror . "/" . $key . "\n";
                    }
                    else
                    {
                        print "[$count:$total] Downloading: $key ..        \r";

                        # download - unless already present.
                        if ( ! -e "$dir/$key" )
                        {
                            system( "wget --quiet -O $dir/$key $mirror/$key" );
                        }
                    }
                }
            }

        }

        if ( !$found )
        {
            print "[Harmless] Failed to find download link for $package\n";
        }

        $CONFIG{'verbose'} && print "+Download $package\n";

        $count += 1;
    }
    print " " x 60 . "\r";
    print "\n";

    #
    #  Now update the cache.
    #
    if( $CONFIG{'cache'} )
    {
        $CONFIG{'verbose'} && print "Copying files to cache directory: $cache\n";

        #
        #  Make sure we have a cache directory.
        #
        mkpath( $cache, 0, 0755 ) if ( ! -d $cache );

        copyPackageFiles( $dir, $cache );
    }
}



=begin doc

  Find the links which are contained in the given HTML
 page.

=end doc

=cut

sub findMirrorContents
{
    my ( $mirror ) = ( @_ );

    #
    #  Download
    #
    my $index = downloadURL( $mirror );

    #
    #  Now we want to store all the links we've found.
    #
    my %links;

    #
    # Parse the HTML.
    #
    foreach my $line ( split( /\n/, $index ) )
    {
        while ( $line =~ /<a href=\"([^\"]+)\">(.*)/ )
        {
            my $link = $1;
            $line    = $2;

            if ( $link =~ /^(.*)\/(.*)$/ )
            {
                $link = $2;
            }
            $links{$link} = 1;
        }
    }

    #
    #  Now we need to do something sneaky.
    #
    #  If we're looking at installing i386, or amd64,
    # then we need to *only* return those things.
    #
    my $i386 = undef;
    $i386 = 1 if ( $CONFIG{'arch'} =~ /i386/ );
    $i386 = 0 if ( $CONFIG{'arch'} =~ /amd64/ );

    foreach my $key ( sort keys %links )
    {
        # i386/i486/i586/i686 packages when we're dealing with amd64 installs.
        if ( ( $key =~ /\.i[3456]86\./ ) && !$i386 )
        {
            delete( $links{$key} );
        }

        # amd64 packages when we're dealing with i386 installs.
        if ( $key =~ /\.x86_64\./ && ($i386) )
        {
            delete( $links{$key} );
        }
    }
    return( %links );
}



=begin doc

  Download the contents of an URL and return it.

=end doc

=cut

sub downloadURL
{
    my( $URL ) = ( @_ );

    #
    #  Create the helper.
    #
    my $ua = LWP::UserAgent->new;
    $ua->timeout(10);
    $ua->env_proxy;

    #
    #  Fetch the URI
    #
    my $response = $ua->get( $URL );

    #
    #  If it worked then return it
    #
    if ($response->is_success)
    {
        return( $response->content );
    }
    else
    {
        print "Failed to fetch : $URL\n";
        print  "\t" . $response->status_line . "\n\n";
        exit;
    }
}



=begin doc

  Unpack each of the RPM files which are contained in the given
 directory.  This is done in two stages:

   1.  Convert to .tgz

   2.  Unarchive.

=end doc

=cut

sub unpackPackages
{
    my( $dir ) = ( @_ );

    #
    #  Get a sorted list of the RPMs
    #
    my @rpms = glob( $dir . "/*.rpm" );
    @rpms    = sort {lc($a) cmp lc($b) } @rpms;

    #
    #  For each RPM file: convert to .tgz
    #
    foreach my $file ( @rpms )
    {
        $CONFIG{'verbose'} && print "-convert $file\n";

        #
        #  Show status
        #
        my $name = $file;
        if ( $name =~ /(.*)\/(.*)/ )
        {
            $name = $2;
        }
        print "Converting RPM $name        \r";

        #
        #  Convert to .tgz
        #
        my $cmd = "cd $dir && alien --to-tgz $file";
        $cmd .= " >/dev/null 2>/dev/null" unless( $CONFIG{'verbose'} );
        system( $cmd );

        #
        #  Note:  We leave the .rpm files in the root of the new
        #        installation directory.  It is assumed the cleanup
        #        script will tidy these up, or otherwise use them.
        #

        $CONFIG{'verbose'} && print "+convert $file\n";
    }
    print " " x 60 . "\r";
    print "\n";

    #
    #  For each .tgz file: unpack
    #
    my @tgz = glob( $dir . "/*.tgz" );
    @tgz    = sort {lc($a) cmp lc($b) } @tgz;
    foreach my $file ( @tgz )
    {
        $CONFIG{'verbose'} && print "-unpack $file\n";

        #
        #  Show status
        #
        my $name = $file;
        if ( $name =~ /(.*)\/(.*)/ )
        {
            $name = $2;
        }
        print "Unpacking $name        \r";

        #
        #  Unpack.
        #
        my $cmd = "cd $dir && tar -zxf $file";
        $cmd .= " >/dev/null 2>/dev/null" unless( $CONFIG{'verbose'} );
        system( $cmd );



        #
        #  Remove
        #
        unlink( $file );

        $CONFIG{'verbose'} && print "+unpack $file\n";
    }
    print " " x 60 . "\r";
    print "\n";
}



=begin doc

  Run the post-installation customization scripts for the given
 distribution.

=end doc

=cut

sub postInstallationCustomization
{
    my( $distribution, $prefix ) = (@_);

    my $scriptDir = "/usr/lib/rinse/$distribution/";

    #
    #  Setup environment for the post-install scripts.
    #
    $ENV{'ARCH'}      = $CONFIG{'arch'};
    $ENV{'mirror'}    = $CONFIG{'mirror'};
    $ENV{'dist'}      = $CONFIG{'distribution'};
    $ENV{'directory'} = $CONFIG{'directory'};


    foreach my $file ( sort( glob( $scriptDir . "/*" ) ) )
    {
        $CONFIG{'verbose'} && print "-script $file\n";

        #
        #  Report on progress all the time.
        #
        my $name = $file;
        if ( $name =~ /(.*)\/(.*)/ )
        {
            $name = $2;
        }
        print "Running post-install script $name\n";
        my $cmd = "$file $prefix";
        system( $cmd );

        $CONFIG{'verbose'} && print "+script $file\n";
    }
}



=begin doc

  Copy a collection of RPM files from one directory to another.

=end doc

=cut

sub copyPackageFiles
{
    my( $src, $dest ) = (@_);

    $CONFIG{'verbose'} && print "- archiving from $src - $dest\n";

    foreach my $file ( sort( glob( $src . "/*.rpm" ) ) )
    {
        # strip path.
        if ( $file =~ /^(.*)\/(.*)$/ )
        {
            $file = $2;
        }

        #
        # if the file isn't already present in the destination then
        # copy it there.
        #
        if ( ! -e $dest . "/" . $file )
        {
            copy( $src  . "/" . $file,
                  $dest . "/" . $file );
        }
    }

    $CONFIG{'verbose'} && print "+ archiving from $src - $dest\n";
}




=begin doc

  Convert something like:

    compat-gcc-34-c++-3.4.6-4.i386.rpm

  into:

    compat-gcc-34

=end doc

=cut

sub packageNameFromFileName
{
    my( $str ) = ( @_ );

    my @parts  = split( /-/, $str );


    my $name     = '';
    my $ver      = '';
    my $foundver = 0;

    foreach my $t ( @parts )
    {
        $foundver = 1 if (( $t =~ /^([0-9bm\.-]+)$/ ) &&
                          ( $t =~ /\./ ) );
        if ( $foundver )
        {
            $ver = $ver . "-" . $t;
        }
        else
        {
            $name = $name . "-" . $t;
        }
    }
    $name =~ s/^-//g if ( $name );
    $ver  =~ s/^-//g if ( $ver );

    return( $name );
}


